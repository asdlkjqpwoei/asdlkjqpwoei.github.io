{
    "version": "https://jsonfeed.org/version/1",
    "title": "Jager的工地 • All posts by \"cpp\" category",
    "description": "游戏开发",
    "home_page_url": "https://asdlkjqpwoei.github.io",
    "items": [
        {
            "id": "https://asdlkjqpwoei.github.io/2023/06/21/StandardTemplateLibrary/",
            "url": "https://asdlkjqpwoei.github.io/2023/06/21/StandardTemplateLibrary/",
            "title": "Standard Template Library",
            "date_published": "2023-06-21T09:18:46.352Z",
            "content_html": "<h1 id=\"标准模板库容器\"><a href=\"#标准模板库容器\" class=\"headerlink\" title=\"标准模板库容器\"></a>标准模板库容器</h1><table>\n<thead>\n<tr>\n<th>容器</th>\n<th>数据结构</th>\n<th>时间复杂度</th>\n<th>元素是否有序</th>\n<th>元素是否可重复</th>\n<th>注意事项</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Array</td>\n<td>数组</td>\n<td>$O(1)$</td>\n<td>无序</td>\n<td>可重复</td>\n<td>支持任意访问</td>\n</tr>\n<tr>\n<td>Vector</td>\n<td>数组</td>\n<td>在尾部操作时$O(1)$，在头部操作时$O(n)$</td>\n<td>无序</td>\n<td>可重复</td>\n<td>支持任意访问</td>\n</tr>\n<tr>\n<td>Deque</td>\n<td>双端队列</td>\n<td>$O(1)$</td>\n<td>无序</td>\n<td>可重复</td>\n<td>支持任意访问</td>\n</tr>\n<tr>\n<td>forward_list</td>\n<td>单向链表</td>\n<td>$O(1)$</td>\n<td>无序</td>\n<td>可重复</td>\n<td>不支持任意访问</td>\n</tr>\n<tr>\n<td>List</td>\n<td>双向链表</td>\n<td>$O(1)$</td>\n<td>无序</td>\n<td>可重复</td>\n<td>不支持任意访问</td>\n</tr>\n<tr>\n<td>Stack</td>\n<td>基于链表，deque&#x2F;lsit</td>\n<td>$O(1)$</td>\n<td>无序</td>\n<td>可重复</td>\n<td>deque&#x2F;list封闭头端开口。</td>\n</tr>\n<tr>\n<td>Queue</td>\n<td>基于链表，deque&#x2F;list</td>\n<td>$O(1)$</td>\n<td>无序</td>\n<td>可重复</td>\n<td>deque&#x2F;list封闭头端开口。</td>\n</tr>\n<tr>\n<td>priority_queue</td>\n<td>vector+max_heap</td>\n<td>$O(log_2n)$</td>\n<td>有序</td>\n<td>可重复</td>\n<td>使用堆处理和规则的vector容器</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>红黑树</td>\n<td>$O(log_2n)$</td>\n<td>有序</td>\n<td>不可重复</td>\n<td>|</td>\n</tr>\n<tr>\n<td>Multiset</td>\n<td>红黑树</td>\n<td>$O(log_2n)$</td>\n<td>有序</td>\n<td>可重复</td>\n<td>|</td>\n</tr>\n<tr>\n<td>Map</td>\n<td>红黑树</td>\n<td>$O(log_2n)$</td>\n<td>有序</td>\n<td>不可重复</td>\n<td>|</td>\n</tr>\n<tr>\n<td>Multimap</td>\n<td>红黑树</td>\n<td>$O(log_2n)$</td>\n<td>有序</td>\n<td>可重复</td>\n<td>|</td>\n</tr>\n<tr>\n<td>unordered_set</td>\n<td>哈希表</td>\n<td>$O(1)-O(n)$</td>\n<td>无序</td>\n<td>不可重复</td>\n<td>|</td>\n</tr>\n<tr>\n<td>unordered_multiset</td>\n<td>哈希表</td>\n<td>$O(1)-O(n)$</td>\n<td>无序</td>\n<td>可重复</td>\n<td>|</td>\n</tr>\n<tr>\n<td>unordered_map</td>\n<td>哈希表</td>\n<td>$O(1)-O(n)$</td>\n<td>无序</td>\n<td>不可重复</td>\n<td>|</td>\n</tr>\n<tr>\n<td>unordered_multimap</td>\n<td>哈希表</td>\n<td>$O(1)-O(n)$</td>\n<td>无序</td>\n<td>可重复</td>\n<td>|</td>\n</tr>\n</tbody></table>\n",
            "tags": []
        },
        {
            "id": "https://asdlkjqpwoei.github.io/2023/06/21/Cpp17/",
            "url": "https://asdlkjqpwoei.github.io/2023/06/21/Cpp17/",
            "title": "Cpp 17",
            "date_published": "2023-06-21T09:00:15.298Z",
            "content_html": "<h1 id=\"命名空间嵌套\"><a href=\"#命名空间嵌套\" class=\"headerlink\" title=\"命名空间嵌套\"></a>命名空间嵌套</h1><h1 id=\"std-optional\"><a href=\"#std-optional\" class=\"headerlink\" title=\"std::optional\"></a>std::optional</h1><p>主要是为了可以让函数可返回多个值。</p>\n<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><p>可捕获对象的副本，而非对象的引用。</p>\n<h1 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h1><p>移除std::auto_ptr。</p>\n",
            "tags": []
        },
        {
            "id": "https://asdlkjqpwoei.github.io/2023/06/21/Cpp11/",
            "url": "https://asdlkjqpwoei.github.io/2023/06/21/Cpp11/",
            "title": "Cpp 11",
            "date_published": "2023-06-21T08:58:37.322Z",
            "content_html": "<h1 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h1><ul>\n<li><p>unique_ptr：独占一个对象和资源，一旦被销毁或者置空，相关资源都会被销毁。拥有另一个对象后，之前的对象和相关资源都会被销毁。</p>\n</li>\n<li><p>weak_ptr：允许共享但不允许拥有一个对象，一旦最后一个拥有该对象的智能指针失去所有权，任何一个weak_ptr都自动为空。</p>\n</li>\n<li><p>shared_ptr：允许共享拥有同一个对象，最后一个拥有该对象shared_ptr会销毁该对象，并清理相关资源。</p>\n</li>\n</ul>\n<h1 id=\"constexpr\"><a href=\"#constexpr\" class=\"headerlink\" title=\"constexpr\"></a>constexpr</h1><p>const未指明该常量是编译器常量还是运行期常量，constexpr告知变量是编译期常量。</p>\n<h1 id=\"可变模板参数\"><a href=\"#可变模板参数\" class=\"headerlink\" title=\"可变模板参数\"></a>可变模板参数</h1><p>允许任意多个、任意类别的模板参数，同时在定义时无需固定参数个数。</p>\n<h1 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h1><p>右值可以是字面常量、表达式、函数返回值，用&amp;&amp;表示，使右值可以出现在赋值语句的左边，可实现移动语义。</p>\n<h1 id=\"移动语义\"><a href=\"#移动语义\" class=\"headerlink\" title=\"移动语义\"></a>移动语义</h1><p>主要是为了降低内存的使用，参数传递的过程中不出现新的无用副本。</p>\n<h1 id=\"完美转发\"><a href=\"#完美转发\" class=\"headerlink\" title=\"完美转发\"></a>完美转发</h1><p>为了解决参数传递时，参数可能已经不是原来内存的问题。</p>\n<p>std::forward&lt;&gt;</p>\n<h1 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h1><p>std::tuple</p>\n<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><p>开始支持Lambda表达式</p>\n<h1 id=\"using定义别名\"><a href=\"#using定义别名\" class=\"headerlink\" title=\"using定义别名\"></a>using定义别名</h1><p>typedef无法重定义模板中的一些语法，using定义别名因此而生。</p>\n",
            "tags": []
        },
        {
            "id": "https://asdlkjqpwoei.github.io/2023/06/21/Cpp/",
            "url": "https://asdlkjqpwoei.github.io/2023/06/21/Cpp/",
            "title": "Cpp Basis",
            "date_published": "2023-06-21T08:12:20.048Z",
            "content_html": "<h1 id=\"Keyword-关键字\"><a href=\"#Keyword-关键字\" class=\"headerlink\" title=\"Keyword(关键字)\"></a>Keyword(关键字)</h1><h2 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h2><ol>\n<li>修饰变量，改变变量的生命周期和存储区域，使变量存储在静态区&#x2F;全局区</li>\n<li>修饰函数，改变函数定义的作用范围，只有定义该函数的文件才可使用该函数，防止与其他人的函数发生同名冲突。</li>\n<li>修饰类的成员变量，使该成员变量不需要实例化对象也可以访问。</li>\n<li>修饰类的成员函数，使该成员函数不需要实例化对象也可被调用。</li>\n</ol>\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><ol>\n<li>修饰变量，使变量不可变化，在声明定义时必须被初始化。</li>\n<li>修饰指针，使其成为常量指针。</li>\n<li>修饰引用，使引用成为常量引用。</li>\n<li>修饰成员函数，使成员函数的定义不可改变成员变量。</li>\n</ol>\n<h1 id=\"指针-Pointer-与引用-Reference\"><a href=\"#指针-Pointer-与引用-Reference\" class=\"headerlink\" title=\"指针(Pointer)与引用(Reference)\"></a>指针(Pointer)与引用(Reference)</h1><ol>\n<li>指针是存储地址的变量，可以为空，不具有对依附性。</li>\n<li>引用时其他变量的别名，必须初始化，具有依附性。</li>\n</ol>\n<h1 id=\"野指针\"><a href=\"#野指针\" class=\"headerlink\" title=\"野指针\"></a>野指针</h1><p>指向垃圾内存的指针。</p>\n<h2 id=\"产生的可能：\"><a href=\"#产生的可能：\" class=\"headerlink\" title=\"产生的可能：\"></a>产生的可能：</h2><ol>\n<li>没有初始化指针，导致指针随机指向一块内存，成为非法指针。</li>\n<li>释放指针所指向的内存后没有将指针置为NULL或者nullptr，成为非法指针。</li>\n<li>指针操作超出变量作用域。</li>\n</ol>\n<h1 id=\"Object-Oriented-Programming-面向对象\"><a href=\"#Object-Oriented-Programming-面向对象\" class=\"headerlink\" title=\"Object Oriented Programming(面向对象)\"></a>Object Oriented Programming(面向对象)</h1><p>类与对象的关系：对象是类的实例化。</p>\n<p>主要特性：封装、多态、继承</p>\n<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><p>将客观存在的事物抽象成类，其中的成员仅对信任的实例开放，多数都是被隐藏和透明的。</p>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>子类继承父类的公共成员定义和实现。</p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>多种状态，有静态多态、动态多态。</p>\n<h3 id=\"静态多态\"><a href=\"#静态多态\" class=\"headerlink\" title=\"静态多态\"></a>静态多态</h3><p>重载函数，在编译时进行绑定。</p>\n<h3 id=\"动态多态\"><a href=\"#动态多态\" class=\"headerlink\" title=\"动态多态\"></a>动态多态</h3><p>与虚函数、虚继承相关。在运行时用基类的引用或者指针调用虚函数会发生绑定，即动态绑定。</p>\n<h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>被virtual修饰的成员函数。</p>\n<h2 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h2><p>被virtual修饰的成员函数，且被赋值0。</p>\n<p>纯虚函数没有实现，无函数体。</p>\n<h3 id=\"重载和覆写\"><a href=\"#重载和覆写\" class=\"headerlink\" title=\"重载和覆写\"></a>重载和覆写</h3><p><em>虚函数</em>可以有实现，可以是空实现，子类继承时与普通继承相似，一样会继承实现，不同的是在子类重新定义函数时，重定义的虚函数叫<em>覆写</em>，重定义的普通函数叫<em>重载</em>。<em>子类</em>可以不覆写虚函数，但是<em>纯虚函数</em>必须被覆写。</p>\n<h3 id=\"虚函数与纯虚函数的区别\"><a href=\"#虚函数与纯虚函数的区别\" class=\"headerlink\" title=\"虚函数与纯虚函数的区别\"></a>虚函数与纯虚函数的区别</h3><p><em>纯虚函数</em>更注重接口的统一性，<em>虚函数</em>用于“实作继承“，继承接口的同时也继承了父类的实现。</p>\n<h2 id=\"接口类\"><a href=\"#接口类\" class=\"headerlink\" title=\"接口类\"></a>接口类</h2><p>成员中有纯虚函数的类。</p>\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>成员中仅有纯虚函数的类。</p>\n<h2 id=\"虚函数表\"><a href=\"#虚函数表\" class=\"headerlink\" title=\"虚函数表\"></a>虚函数表</h2><p>存放指向虚函数的指针的表，存在于目标文件的只读数据段，在编译时根据类的声明创建。如果子类覆写了父类的某个虚函数，则在虚表中覆盖该父类的虚函数指针。这样就可以通过父类指针去调用在子类中覆写虚函数实现，一般都会调用最新的覆写实现。</p>\n<h2 id=\"虚函数指针\"><a href=\"#虚函数指针\" class=\"headerlink\" title=\"虚函数指针\"></a>虚函数指针</h2><p>运行时确定，存在于含有虚函数的类对象中，指向虚函数表。</p>\n<h2 id=\"虚继承\"><a href=\"#虚继承\" class=\"headerlink\" title=\"虚继承\"></a>虚继承</h2><p>主要用于解决在多继承情况下出现的菱形继承问题（浪费存储空间和语义二义性）。</p>\n<h2 id=\"虚基类指针\"><a href=\"#虚基类指针\" class=\"headerlink\" title=\"虚基类指针\"></a>虚基类指针</h2><p>存放虚基类的地址，存在于每一个虚继承的子类。</p>\n<h2 id=\"虚基类表\"><a href=\"#虚基类表\" class=\"headerlink\" title=\"虚基类表\"></a>虚基类表</h2><p>存放虚基类与本类的偏移地址，子类可过该偏移地址找到虚基类。</p>\n<h1 id=\"内存模型\"><a href=\"#内存模型\" class=\"headerlink\" title=\"内存模型\"></a>内存模型</h1><p>栈(Stack)、堆(Heap)、自由存储区、全局&#x2F;静态数据区(全局和静态存在同一块内存中)、常量存储区、自由存储区、执行代码区</p>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>内存分配的运算内置于中央处理器的指令集中，执行函数时，函数内的局部变量会存在栈上，结束时会被释放。</p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>由用户使用new关键字分配的内存，只由应用程序控制，需要使用delete释放堆内存。没有及时释放可能会造成内存泄漏。</p>\n<h2 id=\"全局-x2F-静态数据\"><a href=\"#全局-x2F-静态数据\" class=\"headerlink\" title=\"全局&#x2F;静态数据\"></a>全局&#x2F;静态数据</h2><p>全局变量和静态变量的存储区域，又分为已初始化区和未初始化区。</p>\n<h2 id=\"常量存储区\"><a href=\"#常量存储区\" class=\"headerlink\" title=\"常量存储区\"></a>常量存储区</h2><p>常量的存储区域。</p>\n<h2 id=\"自由存储区\"><a href=\"#自由存储区\" class=\"headerlink\" title=\"自由存储区\"></a>自由存储区</h2><p>由malloc分配的内存，一般用free释放。</p>\n<h2 id=\"执行代码区\"><a href=\"#执行代码区\" class=\"headerlink\" title=\"执行代码区\"></a>执行代码区</h2><p>存放函数体的二进制代码。</p>\n<p>函数执行时，其中的局部变量会被初始化进入栈中，函数执行结束时被弹出。</p>\n<h1 id=\"递归和循环\"><a href=\"#递归和循环\" class=\"headerlink\" title=\"递归和循环\"></a>递归和循环</h1><p>递归其实就是栈和循环的组合。</p>\n<h1 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h1><h2 id=\"模板具体化\"><a href=\"#模板具体化\" class=\"headerlink\" title=\"模板具体化\"></a>模板具体化</h2><p>分为隐式具体化和显式具体化，大多数时候默认都是用隐式具体化，使用通用的模板生成代码。</p>\n<h3 id=\"显式具体化\"><a href=\"#显式具体化\" class=\"headerlink\" title=\"显式具体化\"></a>显式具体化</h3><p>针对特定类型使用特定的模板，显式具体化就有作用了。</p>\n<h3 id=\"部分具体化\"><a href=\"#部分具体化\" class=\"headerlink\" title=\"部分具体化\"></a>部分具体化</h3><p>用来限制模板的通用性。</p>\n<h1 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h1><h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><p>允许变量被未知因素更改，并且不会再被编译器优化。</p>\n<p>多线程接触得少，难以得出更深的理解。</p>\n",
            "tags": []
        }
    ]
}